{
  "originalPath": "src\\api\\aiTrade.ts",
  "timestamp": "2025-10-15T16:14:05.465Z",
  "hash": "d0fc912d6b9659a681a206aa0e9f98fa0cbe927161fd28dc975409652dfe96f8",
  "size": 4669,
  "content": "// Notification utility: SendGrid email integration\r\nimport sgMail from '@sendgrid/mail';\r\nsgMail.setApiKey(process.env.SENDGRID_API_KEY || '');\r\n\r\nasync function notifyTradeStatus(trade, status) {\r\n  const adminEmail = process.env.ADMIN_EMAIL;\r\n  if (!adminEmail || !process.env.SENDGRID_API_KEY) {\r\n    console.log(`Notification: Trade ${status} for`, trade.symbol, trade.amount, trade.side);\r\n    return;\r\n  }\r\n  const subject = `AI Trade ${status.toUpperCase()}: ${trade.symbol} ${trade.side}`;\r\n  const text = `Trade status: ${status}\\n\\nSymbol: ${trade.symbol}\\nSide: ${trade.side}\\nAmount: ${trade.amount}\\nPrice: ${trade.price}\\nOrder Type: ${trade.orderType}\\nSimulation: ${trade.simulation}\\nTimestamp: ${trade.timestamp}\\nMeta: ${JSON.stringify(trade.meta)}\\n`;\r\n  try {\r\n    await sgMail.send({\r\n      to: adminEmail,\r\n      from: adminEmail, // or a verified sender\r\n      subject,\r\n      text\r\n    });\r\n    console.log('Email notification sent:', subject);\r\n  } catch (err) {\r\n    console.error('Failed to send email notification:', err);\r\n  }\r\n}\r\n// Experimental AI Trading API endpoint (Node.js/Express style pseudo-code)\r\n// Place in: /src/api/aiTrade.ts (or your backend functions directory)\r\n\r\n// No express import: use standard request/response signature for edge/serverless\r\nimport { ethers } from 'ethers';\r\nimport { supabase } from '@/lib/supabase';\r\n\r\n// Example: Use env for private key, risk controls, and simulation toggle\r\nconst AI_PRIVATE_KEY = process.env.AI_TRADER_PRIVATE_KEY;\r\nconst SIMULATION_MODE = process.env.AI_TRADER_SIMULATION === 'true';\r\nconst MAX_TRADE_SIZE = parseFloat(process.env.AI_TRADER_MAX_SIZE || '1000'); // USD\r\nconst ALLOWED_PAIRS = (process.env.AI_TRADER_PAIRS || 'BTC-USD,ETH-USD').split(',');\r\n\r\n// Log trades to Supabase (persistent storage)\r\nasync function logTradeToDB(trade: any) {\r\n  const { error } = await supabase.from('ai_trade_logs').insert([trade]);\r\n  if (error) {\r\n    console.error('Failed to log AI trade:', error);\r\n  }\r\n}\r\n\r\n// Compatible with Vercel/Next.js/Supabase Edge Functions\r\nexport default async function aiTradeHandler(req, res) {\r\n  const { symbol, side, amount, price, orderType, meta } = req.body;\r\n  // Risk controls\r\n  if (!ALLOWED_PAIRS.includes(symbol)) {\r\n    return res.status(400).json({ success: false, error: 'Pair not allowed' });\r\n  }\r\n  if (parseFloat(amount) > MAX_TRADE_SIZE) {\r\n    return res.status(400).json({ success: false, error: 'Trade size exceeds limit' });\r\n  }\r\n\r\n  // Determine if trade should be auto-approved\r\n  let autoApprove = false;\r\n  if (SIMULATION_MODE) {\r\n    autoApprove = true;\r\n  } else if (parseFloat(amount) <= MAX_TRADE_SIZE * 0.1) { // Example: auto-approve small trades\r\n    autoApprove = true;\r\n  }\r\n\r\n  const logEntry: any = {\r\n    timestamp: new Date().toISOString(),\r\n    symbol, side, amount, price, orderType, meta,\r\n    simulation: SIMULATION_MODE,\r\n    status: autoApprove ? 'approved' : 'pending'\r\n  };\r\n\r\n  await logTradeToDB(logEntry);\r\n  // Notify on trade creation (pending or auto-approved)\r\n  await notifyTradeStatus(logEntry, logEntry.status);\r\n\r\n  if (SIMULATION_MODE) {\r\n    // Simulate trade (no real execution)\r\n    return res.json({ success: true, simulated: true, log: logEntry });\r\n  }\r\n\r\n  // Check for admin approval before executing real trade\r\n  // Find the latest log for this trade (by timestamp, symbol, side, amount, etc.)\r\n  const { data: logs, error } = await supabase\r\n    .from('ai_trade_logs')\r\n    .select('*')\r\n    .eq('timestamp', logEntry.timestamp)\r\n    .eq('symbol', symbol)\r\n    .eq('side', side)\r\n    .eq('amount', amount)\r\n    .order('timestamp', { ascending: false })\r\n    .limit(1);\r\n  const dbLog = logs && logs[0];\r\n  if (!dbLog || dbLog.status !== 'approved') {\r\n    // Not approved yet, return as pending\r\n    if (dbLog) await notifyTradeStatus(dbLog, dbLog.status);\r\n    return res.json({ success: true, pending: true, log: logEntry, message: 'Trade pending admin approval.' });\r\n  }\r\n\r\n  // Real trade logic (example for EVM chains)\r\n  try {\r\n    const provider = new ethers.JsonRpcProvider(process.env.AI_TRADER_RPC_URL);\r\n    const wallet = new ethers.Wallet(AI_PRIVATE_KEY, provider);\r\n    // ...construct and send trade (e.g., via contract or exchange API)\r\n    // For demo, just log and return\r\n    logEntry.tx = '0xSIMULATED_TX_HASH';\r\n    await notifyTradeStatus(logEntry, 'executed');\r\n    return res.json({ success: true, executed: true, log: logEntry });\r\n  } catch (err: any) {\r\n    logEntry.error = err.message || err;\r\n    await notifyTradeStatus(logEntry, 'error');\r\n    return res.status(500).json({ success: false, error: err.message || err, log: logEntry });\r\n  }\r\n}\r\n"
}